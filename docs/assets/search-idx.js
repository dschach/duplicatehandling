export default [
    {
        "title": "Home",
        "fileName": "index.html",
        "text": "Home Duplicate Management Enhancements This application is designed to run on the Salesforce Platform. Changelog Table of contents Changelog Package Installation Quick Deploy Installing the app using a Scratch Org Installing the app using a Scratch Org(Step-by-step) Installing the App using a Developer Edition Org or a Trailhead Playground Package Installation Quick Deploy Installing the app using a Scratch Org Set up your environment. Follow the steps in the Quick Start: Lightning Web Components  Trailhead project. The steps include: Enable Dev Hub in your Trailhead Playground Install Salesforce CLI Install Visual Studio Code Install the Visual Studio Code Salesforce extensions, including the Lightning Web Components extension If you haven't already done so, authorize your hub org and provide it with an alias(myhuborg  in the command below): sf org login web --set-default-dev-hub --alias myhuborg Clone the duplicatehandling repository: git clone https://github.com/dschach/duplicatehandling cd duplicatehandling Run the npm script to create a scratch org, assign the permission set, and open the org npm run scratchorg That's it! Installing the app using a Scratch Org(Step-by-step) Set up your environment. Follow the steps in the Quick Start: Lightning Web Components  Trailhead project. The steps include: Enable Dev Hub in your Trailhead Playground Install Salesforce CLI Install Visual Studio Code Install the Visual Studio Code Salesforce extensions, including the Lightning Web Components extension If you haven't already done so, authorize your hub org and provide it with an alias(myhuborg  in the command below): sf org login web --set-default-dev-hub --alias myhuborg Clone the duplicatehandling repository: git clone https://github.com/dschach/duplicatehandling cd duplicatehandling Create a scratch org and provide it with an alias(duplicatehandling  in the command below): sf org create scratch --definition-file config/project-scratch-def.json --durationdays 10 --alias duplicatehandling --set-default Push the app to your scratch org: sf project deploy start Assign the Duplicates Handler  permission set to the default user: sf org assign permset --name Duplicates_Handler Open the scratch org: sf org open Installing the App using a Developer Edition Org or a Trailhead Playground Follow this set of instructions if you want to deploy the app to a more permanent environment than a Scratch org. This includes non source-tracked orgs such as a free Developer Edition Org  or a Trailhead Playground . Make sure to start from a brand-new environment to avoid conflicts with previous work you may have done. Clone this repository: git clone https://github.com/dschach/duplicatehandling cd duplicatehandling Authorize your Trailhead Playground or Developer org and provide it with an alias(mydevorg  in the command below): sf org login web --set-default-dev-hub --alias mydevorg Run this command in a terminal to deploy the app. sf project deploy start --source-dir force-app Assign the Duplicates_Handler  permission set to the default user. sf org assign permset --name Duplicates_Handler If your org isn't already open, open it now: sf org open --target-org mydevorg"
    },
    {
        "title": "changelog",
        "fileName": "changelog.html",
        "text": "Changelog 2.0.0(2023-02-21) Bug Fixes Release-please Chore header(#32 )(78178b2 ) Build System release-please:  Reset changelog(dc30d06 ) release-please:  Update r-p files(#27 )(0ea9832 ) Chores Bootstrap releases for path: .(ff771c3 ) docs:  Run ApexDox(2069818 ) docs:  Update code comments(2069818 ) main:  Release duplicatehandling 1.0.0(#28 )(744cc40 ) Release 1.0.0(0a17fd1 ) Reset to v0(4748a39 ) utils:  Workflow streamlining(b9a9a1d ) 1.0.0(2023-02-14) Features Clean up DRS with 1 or 0 records(2069818 ) Initial Release(0a17fd1 ) Update API to 56.0(2069818 ) utils:  Add workflow for PRs to handle dependabot automatically(68ebcb0 ) utils:  Create Changelog file(d975c3c ) Bug Fixes Auto-prepend fix to dependabot changes(b9a9a1d ) Avoid running codecov twice(b9a9a1d ) README typo for script execution(b4913ca ) Report folder visibility(2069818 ) sfdx:  Only run scratch org on SFDX metadata(733c562 ) utils:  Fix secret name for auto scratch org creation(68ebcb0 ) utils:  Husky pre-commit(b0d7120 ) utils:  Release-please action command(9ec754f ) utils:  Remove unnecessary LWC linting(none in project)(68ebcb0 ) utils:  Update workflow to use sfdx commands(b0d7120 ) Build System Bump husky from 8.0.2 to 8.0.3(#17 )(21cd1be ) Bump lint-staged from 13.1.0 to 13.1.2(#25 )(f95421b ) npm:  Bump prettier from 2.8.1 to 2.8.4(#20 )(9723671 )"
    },
    {
        "title": "DuplicateRecordHandlersTest",
        "fileName": "DuplicateRecordHandlersTest.html",
        "text": "DuplicateRecordHandlersTest Tests for DuplicateRecord trigger handlers Signature @isTest private class DuplicateRecordHandlersTest See DuplicateRecordItemTriggerHandler , DuplicateRecordSetTriggerHandler Author David Schach Since 11/13/2019 Initial Version 02/28/2022 PMD-identified cleanup DuplicateRecordHandlersTest Methods dupeAccountsCreate() dupeAccountsMerge() dupeAccountsUpdate() dupeContactsCreate() dupeContactsMerge() dupeLeadsCreate() dupeLeadsMerge() dupeLeadsMergeFuture() futureMergeLeads(lId) We have a future method to allow us to run our trigger handler in future context makeData() setupAccounts(acctCount) setupContact(acctId) setupContacts(accts) setupLead() dupeAccountsCreate() Signature @isTest private static void dupeAccountsCreate() dupeAccountsMerge() Signature @isTest private static void dupeAccountsMerge() dupeAccountsUpdate() Signature @isTest private static void dupeAccountsUpdate() dupeContactsCreate() Signature @isTest private static void dupeContactsCreate() dupeContactsMerge() Signature @isTest private static void dupeContactsMerge() dupeLeadsCreate() Signature @isTest private static void dupeLeadsCreate() dupeLeadsMerge() Signature @isTest private static void dupeLeadsMerge() dupeLeadsMergeFuture() Signature @isTest private static void dupeLeadsMergeFuture() futureMergeLeads(lId) We have a future method to allow us to run our trigger handler in future context Signature @future private static void futureMergeLeads(Id lId) Parameters lId Type: Id Lead Id to keep when merging leads in test class makeData() Signature @TestSetup static void makeData() setupAccounts(acctCount) Signature static List<Account> setupAccounts(Integer acctCount) setupContact(acctId) Signature static Contact setupContact(Id acctId) setupContacts(accts) Signature static List<Contact> setupContacts(List<Account> accts) setupLead() Signature static Lead setupLead()"
    },
    {
        "title": "DuplicateRecordItemTriggerHandler",
        "fileName": "DuplicateRecordItemTriggerHandler.html",
        "text": "DuplicateRecordItemTriggerHandler Trigger Handler for DuplicateRecordItem Signature public inherited sharing class DuplicateRecordItemTriggerHandler See DuplicateRecordHandlersTest Author David Schach Since 04/19/2021     Initial Version 02/28/2022     Static to instance trigger handler methods DuplicateRecordItemTriggerHandler Methods assortDuplicateItems(newRecords) Assign object type and then handle all records handleAccounts(newAccounts, recordIDs) Handle Accounts(may be duplicated for any object) handleContacts(newContacts, recordIDs) Handle Contacts(may be duplicated for any object) handleLeads(newLeads, recordIDs) Handle Leads(may be duplicated for any object) handleTrigger(newRecords, oldRecords, newRecordsMap, oldRecordsMap, triggerEvent) Handle all trigger records updateDuplicateRecordSet(newRecords) Update the parent DuplicateRecordItem  records assortDuplicateItems(newRecords) Assign object type and then handle all records Signature private void assortDuplicateItems(List<DuplicateRecordItem> newRecords) Parameters newRecords Type: List<DuplicateRecordItem> Trigger.new Author David Schach handleAccounts(newAccounts, recordIDs) Handle Accounts(may be duplicated for any object) Signature private void handleAccounts(List<DuplicateRecordItem> newAccounts, Set<Id> recordIDs) Parameters newAccounts Type: List<DuplicateRecordItem> Trigger.new recordIDs Type: Set<Id> AccountIDs, which are technically in newAccounts, but included for simplicity Author David Schach handleContacts(newContacts, recordIDs) Handle Contacts(may be duplicated for any object) Signature private void handleContacts(List<DuplicateRecordItem> newContacts, Set<Id> recordIDs) Parameters newContacts Type: List<DuplicateRecordItem> Trigger.new recordIDs Type: Set<Id> ContactIDs, which are technically in newContacts, but included for simplicity Author David Schach handleLeads(newLeads, recordIDs) Handle Leads(may be duplicated for any object) Signature private void handleLeads(List<DuplicateRecordItem> newLeads, Set<Id> recordIDs) Parameters newLeads Type: List<DuplicateRecordItem> Trigger.new recordIDs Type: Set<Id> LeadIDs, which are technically in newLeads, but included for simplicity Author David Schach handleTrigger(newRecords, oldRecords, newRecordsMap, oldRecordsMap, triggerEvent) Handle all trigger records Signature public void handleTrigger(\t\tList<DuplicateRecordItem> newRecords,\t\tList<DuplicateRecordItem> oldRecords,\t\tMap<Id, DuplicateRecordItem> newRecordsMap,\t\tMap<Id, DuplicateRecordItem> oldRecordsMap,\t\tSystem.TriggerOperation triggerEvent\t) Parameters newRecords Type: \t\tList<DuplicateRecordItem> Trigger.new oldRecords    Trigger.old newRecordsMap Type: DuplicateRecordItem> Trigger.newMap oldRecordsMap Type: DuplicateRecordItem> Trigger.oldMap triggerEvent  Trigger context enum Author David Schach updateDuplicateRecordSet(newRecords) Update the parent DuplicateRecordItem  records Signature private void updateDuplicateRecordSet(List<DuplicateRecordItem> newRecords) Parameters newRecords Type: List<DuplicateRecordItem> Trigger.new Author David Schach"
    },
    {
        "title": "DuplicateRecordSetTriggerHandler",
        "fileName": "DuplicateRecordSetTriggerHandler.html",
        "text": "DuplicateRecordSetTriggerHandler Trigger Handler for DuplicateRecordSet Signature public inherited sharing class DuplicateRecordSetTriggerHandler See DuplicateRecordHandlersTest Author David Schach Since 04/19/2021 Initial Version 04/19/2021 Moved deletion of sets to the Item trigger handler for more control and to delete 0 record count sets 02/28/2022 Static to instance trigger handler methods 09/14/2022 Salesforce may be auto-deleting single-record sets, so setting allOrNothing to false DuplicateRecordSetTriggerHandler Methods deleteSingleRecordSetsFuture(candidatesToDelete) Future delete DuplicateRecordSet  records with only 1 DuplicateRecordItem deleteUnnecessaryRecordSets(candidatesToDelete) Declare deletion in a synchronous method so it can be called from either the main handler class or an asychronous method.(DRY) findSingleRecordSets(newRecords, oldRecordsMap) Query for all single-item DuplicateRecordSet  records First we exclude DRS records where the DRI count was and is zero. This allows us to instantiate the record. We don't know why DRS records are also updated when they are created, but that's the situation. Then we delete DRS records where RecordCount < 2(0 or 1) and can do so because we allowed the creation of the DRS. handleTrigger(newRecords, oldRecords, newRecordsMap, oldRecordsMap, triggerEvent) Handle all trigger records deleteSingleRecordSetsFuture(candidatesToDelete) Future delete DuplicateRecordSet  records with only 1 DuplicateRecordItem Signature @future public static void deleteSingleRecordSetsFuture(Set<Id> candidatesToDelete) Parameters candidatesToDelete Type: Set<Id> Queried DuplicateRecordSet  records with 1 DuplicateRecordItem Author David Schach deleteUnnecessaryRecordSets(candidatesToDelete) Declare deletion in a synchronous method so it can be called from either the main handler class or an asychronous method.(DRY) Signature private static void deleteUnnecessaryRecordSets(Set<Id> candidatesToDelete) Parameters candidatesToDelete Type: Set<Id> DuplicateRecordSet  IDs to delete findSingleRecordSets(newRecords, oldRecordsMap) Query for all single-item DuplicateRecordSet  records First we exclude DRS records where the DRI count was and is zero. This allows us to instantiate the record. We don't know why DRS records are also updated when they are created, but that's the situation. Then we delete DRS records where RecordCount < 2(0 or 1) and can do so because we allowed the creation of the DRS. Signature public void findSingleRecordSets(List<DuplicateRecordSet> newRecords, Map<Id, DuplicateRecordSet> oldRecordsMap) Parameters newRecords Type: List<DuplicateRecordSet> Trigger.new oldRecordsMap Type: Map<Id, DuplicateRecordSet> Trigger.oldMap Author David Schach handleTrigger(newRecords, oldRecords, newRecordsMap, oldRecordsMap, triggerEvent) Handle all trigger records Signature public void handleTrigger(\t\tList<DuplicateRecordSet> newRecords,\t\tList<DuplicateRecordSet> oldRecords,\t\tMap<Id, DuplicateRecordSet> newRecordsMap,\t\tMap<Id, DuplicateRecordSet> oldRecordsMap,\t\tSystem.TriggerOperation triggerEvent\t) Parameters newRecords Type: \t\tList<DuplicateRecordSet> Trigger.new oldRecords    Trigger.old newRecordsMap Type: DuplicateRecordSet> Trigger.newMap oldRecordsMap Type: DuplicateRecordSet> Trigger.oldMap triggerEvent  Trigger context enum Author David Schach"
    }
];
